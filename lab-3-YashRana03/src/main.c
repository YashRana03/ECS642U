#include <stdbool.h>
#include <stdint.h>
#include <MKL25Z4.h>

#include "..\inc\SysTick.h"
#include "..\inc\button.h"
#include "..\inc\rgb.h"



/*----------------------------------------------------------------------------
   nextRand: get the next random number
   Based on https://en.wikipedia.org/wiki/Linear_congruential_generator
 * ---------------------------------------------------------------------------*/
uint32_t seed = 0x12345678;

// Returns a 32-bit number which is too long for us
uint32_t nextRand(void) {
    seed = (1103515245 * seed + 12345);
    return seed;
}

// Generate random in the range 0 to 900
// - take the top 10 bits - the max is 1023
// - reject if > 900 (about 10% probability)
uint32_t rand900(uint32_t r) {
    uint32_t r900 = (r & 0xFFC00000) >> 22; // top 10 bits
    while (r900 > 900) r900 = (nextRand() & 0xFFC00000) >> 22;
    return r900;
}

/*----------------------------------------------------------------------------
   Variables for communication
 *----------------------------------------------------------------------------*/
volatile uint32_t pressedB5_ev;  // set by the interrupt handler
                                 // Cleared by the task

/*----------------------------------------------------------------------------
   Interrupt Handler GPIO A
   - Clear the pending request
   - Test the bit to see if it generated the interrupt
 *----------------------------------------------------------------------------*/

#define RED (0)
#define GREEN (1)
#define REDBLUE (2)
#define GREENBLUE (3)
#define FLASHTIME (100)

// States of the task
#define READY (4)
#define RANDOMWAIT (5)
#define TIMING (6)
#define ERROR (7)
#define SUCCESSON (8)
#define SUCCESSOFF (9)
#define ERRORON (10)
#define ERROROFF (11)

int state3Leds = READY; // This variable keeps track of the current state of the task

int randomTime = 0; // Variable created to carry the value of the random time generated to turn on the green LED

int finalUserTime; // This variable will be used to hold the final reaction time of the user

void PORTA_IRQHandler(void) {
    NVIC_ClearPendingIRQ(PORTA_IRQn);
    uint32_t timerCounter;
    if ((PORTA->ISFR & B5MASK)) {
        // Add code to respond to the interrupt generated by B5
        pressedB5_ev = 1;
        // When the user presses B5, different actions are taken depending on the state of the task
        switch (state3Leds) {

            // If the task has the READY state, the counter1msON flag is set to true, which
            // causes the counter1ms to be incremented every 1 ms in SysTick.c
        case READY:
            counter1msON = true;
            break;

            // If the task has the RANDOMWAIT state, it means the user pressed before the green LED turned on
            // Therefore the counter is set back to 0 and turned off
        case RANDOMWAIT:
            finalUserTime = 0;
            counter1ms = 0;
            counter1msON = false;
            break;

            // If the task has the TIMING state, the user reaction time is calculated by taking away
            // the time spent waiting for the green LED from the counter1ms. The result is then stored in
            // finalUserTime. The counter is set to 0 and turned off
        case TIMING:
            finalUserTime = counter1ms - randomTime * 10;
            counter1ms = 0;
            counter1msON = false;
            break;
        }

    }
    // Clear status flags
    PORTA->ISFR = B5MASK;
}

int stateTask1;  // this variable holds the current state
uint32_t counter1;    // counter for periodic flash
uint32_t counter2;    // counter for random countdown

// Used to initialise taskTimeReaction
void initTask() {
    stateTask1 = READY;     // initialize the state
    setRGB(RED, RGB_ON);    // turn the red LED on
    setRGB(BLUE, RGB_OFF);  // turn the LED off
    setRGB(GREEN, RGB_OFF); // turn the green LED off
    counter1 = FLASHTIME; // set the flash time
    counter2 = 0;         // not used in the initial state
}


/*----------------------------------------------------------------------------
   taskTimeReaction

   * Records the user reaction time by turning on a green LED at a random time.
   * The user must then press the B5 button. If the button is pressed before the green LED turned on
   * the task will flash the red light. Instead if the user pressed after the green LED turned on,
   * the green LED flashes
 *----------------------------------------------------------------------------*/

int randomNum = 0;  // This variable records how long the user took to press the B5 button to say they are ready

void taskTimeReaction() {

    // Checks the current state of the task
    switch (state3Leds) {

    // If the task is in the READY state
    case READY:
        // randomNum is incremented in each cycle
        randomNum++;
        // If the user presses B5
        if (pressedB5_ev) {
            pressedB5_ev = false;
            // State is changed to RANDOMWAIT
            state3Leds = RANDOMWAIT;
            // RED LED is turned off
            setRGB(RED, RGB_OFF);
            // The randomNum is added to the seed. This will make the random number generated
            // Truly random each time the microcontroller is reset
            seed += randomNum;
            // Random num is generated and set for countdown in counter2
            counter2 = rand900(nextRand()) + 100;
            // A copy of the random number is kept in randomTime
            randomTime = counter2;
        }
        break;

    // If the task is in RANDOMWAIT
    case RANDOMWAIT:
        // Decrements the counter2 each time
        if (counter2 > 0) counter2--;
        // If B5 is pressed and the counter has not counted down to zero yet
        if (pressedB5_ev && counter2 > 0) {
            pressedB5_ev = false;
            // State is changed to ERRORON
            state3Leds = ERROROFF;
            counter1 = 0;
        }
        // When the counter is down to 0
        if (counter2 == 0) {
            // Green LED is turned on
            setRGB(GREEN, RGB_ON);
            // The state is changed to TIMING
            state3Leds = TIMING;
        }
        break;

    // If the task is in TIMING
    case TIMING:
        // If B5 is pressed
        if (pressedB5_ev) {
            pressedB5_ev = false;
            // State is changed to SUCCESSON
            state3Leds = SUCCESSON;
            // Counter1 is set to 0
            counter1 = 0;
        }
        break;

    // If the state is SUCCESSOFF
    case SUCCESSOFF:
        // Decrements the counter if greater than 0
        if (counter1 > 0) counter1--;

        if (counter1 == 0) {
            // State is changed to SUCCESSON
            state3Leds = SUCCESSON;
            // Counter1 is set back to 100
            counter1 = FLASHTIME;
            // Green LED is turned on
            setRGB(GREEN, RGB_ON);
        }
        break;

    // If state is SUCCESSON
    case SUCCESSON:
        // Decrements the counter if greater than 0
        if (counter1 > 0) counter1--;
        // If counter goes down to 0
        if (counter1 == 0) {
            // Change state to SUCCESSOFF
            state3Leds = SUCCESSOFF;
            // Set counter1 back to 100
            counter1 = FLASHTIME;
            // Turn the green LED off
            setRGB(GREEN, RGB_OFF);
        }
        break;

    // If state is ERRORON
    case ERRORON:
        // Decrements the counter if greater than 0
        if (counter1 > 0) counter1--;

        // If counter1 goes down to 0
        if (counter1 == 0) {
            // Set state to ERROROFF
            state3Leds = ERROROFF;
            // Set counter1 back to 100
            counter1 = FLASHTIME;
            // Turn the red LED off
            setRGB(RED, RGB_OFF);
        }
        break;

    // If state is ERROROFF
    case ERROROFF:
        // Decrements the counter if greater than 0
        if (counter1 > 0) counter1--;

        // If counter1 goes down to 0
        if (counter1 == 0) {
            // Set state to ERRORON
            state3Leds = ERRORON;
            // Set counter1 back to 100
            counter1 = FLASHTIME;
            // Turn the red LED on
            setRGB(RED, RGB_ON);
        }
        break;

    }

}

/*----------------------------------------------------------------------------
   MAIN function
 *----------------------------------------------------------------------------*/
int main(void) {
    configureRGB();                 // configure RGB using GPIO
    configureButtons(B5MASK, true); // configure button B5 (with an interrupt)
    initTask();                // initialize task1 state
    Init_SysTick(1000);             // initialize SysTick every 1ms
    waitSysTickCounter(10);
    while (1) {                   // this runs forever
        // Call the task
        taskTimeReaction();
        // delay
        waitSysTickCounter(10);  // cycle every 10 ms
    }
}